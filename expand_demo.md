# Private Token Demo Playbook

This walkthrough explains how to run the new verbose demo (`npm run private-token-demo`) and how each step proves that end users can track their private balances while the public ledger remains oblivious.

---

## 1. Prerequisites

1. **Fresh consensus build**  
   ```bash
   cd ../hiero-consensus-node
   export JAVA_HOME=/opt/homebrew/opt/openjdk@21/libexec/openjdk.jdk/Contents/Home
   export PATH="$JAVA_HOME/bin:$PATH"
   ./gradlew :app:assemble
   ```
   This refreshes `hedera-node/data/apps/HederaNode.jar` with the latest private-token patches (block stream guard + ServiceScopeLookup mapping).

2. **Solo workspace**  
   All commands below assume the current directory is `solo-private-tokens/workspace/solo`.

3. **Kind + Solo deployment**  
   ```bash
   KEEP_ENVIRONMENT=1 ./scripts/private-token-e2e.sh
   ```
   The script:
   - Creates the `solo-private-token` Kind cluster (or reuses it if `REUSE_KIND_CLUSTER=1`).
   - Deploys the Falcon one-shot network with your locally built `HederaNode.jar`.
   - Patches `/opt/hgcapp/services-hedera/HapiApp2.0/data/config/application.properties` inside the running pod to force `blockStream.streamMode=RECORDS` and `blockStream.writerMode=FILE`, then restarts `network-node.service`.
   - Captures deployment metadata under `.solo-private-token/private-token-spec.*`, which the demo reads to find the namespace, pod, and gRPC endpoint.

> Keep this terminal running so the cluster stays alive; open a second terminal for the demo.

---

## 2. Running the verbose demo

1. **Open another terminal:**  
   ```bash
   cd solo-private-tokens/workspace/solo
   npm run private-token-demo
   ```

2. **What the script does (annotated output is provided in-line):**
   - Connects to the forwarded gRPC endpoint and creates a local `PrivateWallet` tracker.
   - Creates a recipient account (`AccountCreateTransaction`) and a fungible private token (`TokenCreateTransaction`) with `INITIAL_SUPPLY = 1000`.
   - Associates the recipient with the token.
   - Scrapes the node logs for the “Initial private supply…” entry to learn the treasury’s first Pedersen commitment, then records it in the local wallet with the note “Minted during token creation (blinding generated by network)”.
   - Prints two perspectives:
     - `[Private Wallet] Treasury private view after mint … 1000 units …`.
     - `[Public Ledger] Treasury public view after mint: 0`.
   - Splits the treasury commitment into `300` (recipient) + `700` (change), generating fresh Pedersen blinding factors client-side.
   - Submits a `PRIVATE_TOKEN_TRANSFER` with those commitments.
   - Updates the local wallet: removes the consumed commitment, adds the change commitment for the treasury, and stores the recipient commitment with its known blinding.
   - Shows ledger vs. wallet again:
     - `[Public Ledger] Treasury public view after transfer: 0`
     - `[Public Ledger] Recipient public view after transfer: 0`
     - `[Private Wallet] Treasury private view after transfer … 700 units …`
     - `[Private Wallet] Recipient private view after transfer … 300 units …`
   - Attempts a public HTS `TransferTransaction` for the same token amount; the network returns `NOT_SUPPORTED`, confirming that the private token cannot be moved via the visible path.
   - Shuts down the SDK client and prints “Demo complete…”.

This side-by-side view demonstrates that:
- Users/operators retain full knowledge of their holdings (commitment hex + local blinding) via the wallet printouts.
- The public `AccountBalanceQuery` never exposes those holdings; it remains zero before and after the transfer.

---

## 3. Suggested talking points while presenting

1. **Mint phase:** “Treasury sees 1000 units in its private wallet, yet the ledger reports 0. Regulators/observers cannot infer anything from the record stream.”
2. **Transfer phase:** “We crafted the recipient commitment locally, so we know both the amount and the blinding. The ledger still shows zero because only commitments—not cleartext balances—are written to state.”
3. **Change handling:** “The treasury receives a change commitment; our wallet tracks it even though the blinding was computed in-node.”
4. **Public transfer guard:** “If someone tries to move the token via a regular `TransferTransaction`, HTS rejects it with `NOT_SUPPORTED`. All private movement must go through `PRIVATE_TOKEN_TRANSFER` with commitments.”

---

## 4. Cleanup

When you are done demonstrating:

```bash
kind delete cluster --name solo-private-token
rm -rf .solo-private-token/private-token-spec.*
```

You can always redeploy with `KEEP_ENVIRONMENT=1 ./scripts/private-token-e2e.sh` before re-running the demo.

---

## 5. Extending the demo

- Adjust `INITIAL_SUPPLY` / `TRANSFER_AMOUNT` in `examples/tests/privateTokenDemo.spec.ts` to walk through larger splits or chained transfers.
- Add more `PrivateWallet` entries if you want to simulate multiple recipients or multi-hop transfers.
- Pair the console output with `kubectl logs` to show that even node logs only record commitment hex—not cleartext values.

This checklist should make it straightforward for engineers (or solutions architects) to showcase the privacy guarantees and developer ergonomics of the new flow.
